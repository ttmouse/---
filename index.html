<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小蜜蜂游戏</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        .game-container {
            position: relative;
        }
        canvas {
            border: 2px solid #fff;
            background: linear-gradient(to bottom, #001122, #003366);
        }
        .game-info {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 16px;
            display: flex;
            justify-content: center;
            gap: 30px;
            align-items: center;
            z-index: 10;
            width: 700px;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            text-align: center;
            font-size: 24px;
            display: none;
        }
        .controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: #fff;
            font-size: 14px;
            z-index: 10;
        }
        .level-info {
            display: none;
        }
        .power-up {
            position: absolute;
            top: 75px;
            left: 15px;
            color: #00ff00;
            font-size: 14px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="game-info">
             <div>得分: <span id="score">0</span></div>
             <div>生命: <span id="lives">3</span></div>
             <div>关卡: <span id="level">1</span></div>
             <div>敌机: <span id="enemiesLeft">0</span></div>
             <div>Boss倒计时: <span id="bossCountdown">20</span></div>
         </div>
        <div class="game-over" id="gameOver">
            <h2>游戏结束!</h2>
            <p>最终得分: <span id="finalScore">0</span></p>
            <p>按空格键重新开始</p>
        </div>
        <div class="controls">
             <p>控制: WASD移动, J键射击, M键开关音效</p>
         </div>
        <div class="power-up">
            <div id="powerUpStatus"></div>
            <div id="audioStatus" style="margin-top: 10px; color: #ffff00;">音效: 开启</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');

        // 游戏状态
        let gameState = {
            score: 0,
            lives: 3,
            gameOver: false,
            keys: {},
            level: 1,
            enemiesKilled: 0,
            enemiesPerLevel: 10,
            activePowerUps: [], // 改为数组存储多个激活的道具
            totalEnemiesKilled: 0,
            bossSpawnCount: 20,
            invulnerable: false, // 无敌状态
            invulnerableTime: 0 // 无敌时间倒计时
        };

        // 玩家飞机
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height - 80,
            width: 50,
            height: 40,
            speed: 8,
            color: '#00ff00'
        };

        // 子弹数组
        let bullets = [];
        let enemyBullets = [];

        // 敌机数组
        let enemies = [];

        // 粒子效果数组
        let particles = [];
        
        // 道具数组
        let powerUps = [];
        
        // 游戏元素引用
        const levelElement = document.getElementById('level');
        const enemiesLeftElement = document.getElementById('enemiesLeft');
        const powerUpStatusElement = document.getElementById('powerUpStatus');
        const bossCountdownElement = document.getElementById('bossCountdown');
        
        // 音效系统
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.musicVolume = 0.6;
                this.sfxVolume = 0.5;
                this.enabled = true;
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (e) {
                    console.log('Web Audio API not supported');
                    this.enabled = false;
                }
            }
            
            createSounds() {
                // 创建各种音效
                this.sounds.playerShoot = this.createTone(800, 0.1, 'square');
                this.sounds.enemyShoot = this.createTone(400, 0.15, 'sawtooth');
                this.sounds.explosion = this.createNoise(0.3);
                this.sounds.powerUp = this.createTone(1200, 0.2, 'sine', [1200, 1600, 2000]);
                this.sounds.hit = this.createTone(600, 0.1, 'triangle');
                this.sounds.bossExplosion = this.createNoise(0.5, true);
                
                // 创建背景音乐
                this.createBackgroundMusic();
            }
            
            createBackgroundMusic() {
                this.backgroundMusic = {
                    isPlaying: false,
                    oscillators: [],
                    gainNode: null
                };
                
                this.startBackgroundMusic();
            }
            
            startBackgroundMusic() {
                if (!this.enabled || !this.audioContext || this.backgroundMusic.isPlaying) return;
                
                this.backgroundMusic.gainNode = this.audioContext.createGain();
                this.backgroundMusic.gainNode.connect(this.audioContext.destination);
                this.backgroundMusic.gainNode.gain.setValueAtTime(this.musicVolume * 0.3, this.audioContext.currentTime);
                
                // 创建简单的背景音乐旋律
                const melody = [440, 523, 659, 523, 440, 392, 440, 523]; // A, C, E, C, A, G, A, C
                const rhythm = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5];
                
                let currentTime = this.audioContext.currentTime;
                
                const playMelody = () => {
                    if (!this.enabled || !this.backgroundMusic.isPlaying) return;
                    
                    melody.forEach((freq, index) => {
                        const oscillator = this.audioContext.createOscillator();
                        const noteGain = this.audioContext.createGain();
                        
                        oscillator.connect(noteGain);
                        noteGain.connect(this.backgroundMusic.gainNode);
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(freq, currentTime);
                        
                        noteGain.gain.setValueAtTime(0, currentTime);
                        noteGain.gain.linearRampToValueAtTime(0.1, currentTime + 0.05);
                        noteGain.gain.exponentialRampToValueAtTime(0.01, currentTime + rhythm[index]);
                        
                        oscillator.start(currentTime);
                        oscillator.stop(currentTime + rhythm[index]);
                        
                        currentTime += rhythm[index];
                    });
                    
                    // 循环播放
                    setTimeout(playMelody, melody.length * 500);
                };
                
                this.backgroundMusic.isPlaying = true;
                playMelody();
            }
            
            stopBackgroundMusic() {
                this.backgroundMusic.isPlaying = false;
                if (this.backgroundMusic.gainNode) {
                    this.backgroundMusic.gainNode.disconnect();
                }
            }
            
            createTone(frequency, duration, waveType = 'sine', frequencies = null) {
                return () => {
                    if (!this.enabled || !this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.type = waveType;
                    
                    if (frequencies) {
                        // 创建音调变化效果
                        oscillator.frequency.setValueAtTime(frequencies[0], this.audioContext.currentTime);
                        frequencies.forEach((freq, index) => {
                            oscillator.frequency.linearRampToValueAtTime(
                                freq, 
                                this.audioContext.currentTime + (duration / frequencies.length) * (index + 1)
                            );
                        });
                    } else {
                        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    }
                    
                    gainNode.gain.setValueAtTime(this.sfxVolume, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                };
            }
            
            createNoise(duration, complex = false) {
                return () => {
                    if (!this.enabled || !this.audioContext) return;
                    
                    const bufferSize = this.audioContext.sampleRate * duration;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const output = buffer.getChannelData(0);
                    
                    for (let i = 0; i < bufferSize; i++) {
                        if (complex) {
                            // 复杂爆炸音效
                            output[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
                        } else {
                            // 简单爆炸音效
                            output[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 1.5);
                        }
                    }
                    
                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    
                    source.buffer = buffer;
                    source.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    gainNode.gain.setValueAtTime(this.sfxVolume, this.audioContext.currentTime);
                    
                    source.start(this.audioContext.currentTime);
                };
            }
            
            play(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                
                if (this.enabled) {
                    this.startBackgroundMusic();
                } else {
                    this.stopBackgroundMusic();
                }
                
                return this.enabled;
            }
        }
        
        // 初始化音效管理器
        const audioManager = new AudioManager();

        // 子弹类
        class Bullet {
            constructor(x, y, speed, color = '#ffff00', type = 'normal', angle = 0) {
                this.x = x;
                this.y = y;
                this.width = 4;
                this.height = 10;
                this.speed = speed;
                this.color = color;
                this.type = type;
                this.angle = angle; // 发射角度（弧度）
                this.vx = Math.sin(angle) * speed; // X方向速度
                this.vy = Math.cos(angle) * speed; // Y方向速度
                this.trail = []; // 子弹轨迹
                this.glowIntensity = 0;
                this.animationTimer = 0;
                this.particles = []; // 子弹粒子效果
                
                // 根据类型设置属性
                switch(type) {
                    case 'player':
                        this.width = 3;
                        this.height = 12;
                        this.color = '#00ffff';
                        this.glowColor = '#00ffff';
                        // 玩家子弹向上发射，修正速度向量
                        this.vx = Math.sin(angle) * Math.abs(speed);
                        this.vy = -Math.cos(angle) * Math.abs(speed);
                        break;
                    case 'enemy':
                    case 'normal':
                        this.width = 3;
                        this.height = 8;
                        this.color = color || '#ff6600';
                        this.glowColor = '#ff3300';
                        // 敌机子弹向下发射
                        if (angle === 0) {
                            this.vy = Math.abs(speed);
                            this.vx = 0;
                        }
                        break;
                    case 'fast':
                        this.width = 1.5;
                        this.height = 8;
                        this.color = color || '#00ffff';
                        this.glowColor = '#0088ff';
                        // 快速子弹 - 更细长
                        if (angle === 0) {
                            this.vy = Math.abs(speed);
                            this.vx = 0;
                        }
                        break;
                    case 'heavy':
                        this.width = 6;
                        this.height = 12;
                        this.color = color || '#ff00ff';
                        this.glowColor = '#cc00cc';
                        // 重型子弹 - 更大更粗
                        if (angle === 0) {
                            this.vy = Math.abs(speed);
                            this.vx = 0;
                        }
                        break;
                    case 'armored':
                        this.width = 7;
                        this.height = 10;
                        this.color = color || '#888888';
                        this.glowColor = '#666666';
                        // 装甲子弹 - 最粗壮
                        if (angle === 0) {
                            this.vy = Math.abs(speed);
                            this.vx = 0;
                        }
                        break;
                    case 'scout':
                        this.width = 1;
                        this.height = 12;
                        this.color = color || '#00ff00';
                        this.glowColor = '#00cc00';
                        // 侦察子弹 - 最细最长
                        if (angle === 0) {
                            this.vy = Math.abs(speed);
                            this.vx = 0;
                        }
                        break;
                    case 'boss':
                        this.width = 8;
                        this.height = 15;
                        this.color = '#ff0000';
                        this.glowColor = '#ff6600';
                        // Boss子弹 - 最大最威猛
                        if (angle === 0) {
                            this.vy = Math.abs(speed);
                            this.vx = 0;
                        }
                        break;
                    case 'powerShot':
                        this.width = 5;
                        this.height = 15;
                        this.color = '#ffff00';
                        this.glowColor = '#ffaa00';
                        // 强化子弹向上发射，修正速度向量
                        this.vx = Math.sin(angle) * Math.abs(speed);
                        this.vy = -Math.cos(angle) * Math.abs(speed);
                        break;
                    case 'upgraded':
                        this.width = 4;
                        this.height = 14;
                        this.color = color || '#00ff80';
                        this.glowColor = color || '#00ff80';
                        // 升级子弹向上发射，修正速度向量
                        this.vx = Math.sin(angle) * Math.abs(speed);
                        this.vy = -Math.cos(angle) * Math.abs(speed);
                        break;
                }
            }

            update() {
                // 保存轨迹
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 8) {
                    this.trail.shift();
                }
                
                // 使用速度向量移动
                this.x += this.vx;
                this.y += this.vy;
                this.animationTimer += 0.3;
                this.glowIntensity = Math.sin(this.animationTimer) * 0.3 + 0.7;
                
                // 为玩家子弹添加粒子效果
                if (this.type === 'player' || this.type === 'powerShot') {
                    if (Math.random() < 0.3) {
                        this.particles.push({
                            x: this.x + this.width/2 + (Math.random() - 0.5) * 4,
                            y: this.y + this.height,
                            vx: (Math.random() - 0.5) * 2,
                            vy: Math.random() * 2 + 1,
                            life: 15,
                            maxLife: 15,
                            color: this.glowColor
                        });
                    }
                }
                
                // 更新粒子
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    particle.vx *= 0.95;
                    particle.vy *= 0.95;
                    return particle.life > 0;
                });
            }

            draw() {
                // 绘制轨迹（仅玩家子弹和强化子弹有轨迹效果）
                if (this.trail.length > 1 && (this.type === 'player' || this.type === 'powerShot')) {
                    ctx.save();
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const alpha = (i + 1) / this.trail.length * 0.5;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = this.color;
                        const size = (i + 1) / this.trail.length;
                        ctx.fillRect(
                            this.trail[i].x + this.width/2 - size,
                            this.trail[i].y + this.height/2 - size * 2,
                            size * 2,
                            size * 4
                        );
                    }
                    ctx.restore();
                }
                
                // 绘制发光效果
                if (this.glowColor) {
                    ctx.save();
                    ctx.shadowColor = this.glowColor;
                    ctx.shadowBlur = 10 * this.glowIntensity;
                    ctx.fillStyle = this.glowColor;
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
                    ctx.restore();
                }
                
                // 绘制主体 - 小蜜蜂风格
                ctx.save();
                if (this.type === 'player') {
                    // 玩家子弹 - 蓝色能量箭矢
                    // 箭矢主体 - 细长流线型
                    ctx.fillStyle = '#0088ff';
                    ctx.fillRect(this.x + 1, this.y + 3, this.width - 2, this.height - 6);
                    
                    // 箭头尖端
                    ctx.fillStyle = '#00ddff';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y);
                    ctx.lineTo(this.x, this.y + 4);
                    ctx.lineTo(this.x + this.width, this.y + 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 箭羽
                    ctx.fillStyle = '#0066cc';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.height - 3);
                    ctx.lineTo(this.x + this.width/2, this.y + this.height - 1);
                    ctx.lineTo(this.x + this.width, this.y + this.height - 3);
                    ctx.lineTo(this.x + this.width/2, this.y + this.height - 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 能量光芒
                    const glowIntensity = Math.sin(this.animationTimer * 3) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(0, 200, 255, ${glowIntensity * 0.4})`;
                    ctx.fillRect(this.x - 1, this.y, this.width + 2, this.height);
                    
                } else if (this.type === 'powerShot') {
                    // 强化子弹 - 金色穿甲弹
                    // 弹体主体
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(this.x + 0.5, this.y + 2, this.width - 1, this.height - 4);
                    
                    // 穿甲弹头
                    ctx.fillStyle = '#ffdd00';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y);
                    ctx.lineTo(this.x + 0.5, this.y + 3);
                    ctx.lineTo(this.x + this.width - 0.5, this.y + 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 弹壳纹理
                    ctx.fillStyle = '#cc8800';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(this.x + 1, this.y + 4 + i * 3, this.width - 2, 1);
                    }
                    
                    // 弹底
                    ctx.fillStyle = '#996600';
                    ctx.fillRect(this.x + 1, this.y + this.height - 2, this.width - 2, 2);
                    
                    // 能量光芒
                    const glowIntensity = Math.sin(this.animationTimer * 4) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.5})`;
                    ctx.fillRect(this.x - 1, this.y, this.width + 2, this.height);
                    
                    // 穿甲尖端高光
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(this.x + this.width/2 - 0.5, this.y, 1, 2);
                    
                } else if (this.type === 'upgraded') {
                    // 升级子弹 - 彩色能量弹
                    // 能量光环
                    const energyPulse = Math.sin(this.animationTimer * 4) * 0.4 + 0.6;
                    ctx.fillStyle = `rgba(${this.color === '#00ff80' ? '0, 255, 128' : this.color === '#ff6600' ? '255, 102, 0' : '128, 0, 255'}, ${energyPulse * 0.5})`;
                    ctx.fillRect(this.x - 1, this.y, this.width + 2, this.height);
                    
                    // 弹体主体
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + 0.5, this.y + 1, this.width - 1, this.height - 2);
                    
                    // 能量核心
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(this.x + this.width/2 - 0.5, this.y + 2, 1, this.height - 4);
                    
                    // 弹头
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y);
                    ctx.lineTo(this.x + 0.5, this.y + 2);
                    ctx.lineTo(this.x + this.width - 0.5, this.y + 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 能量脉冲
                    for (let i = 0; i < 3; i++) {
                        const pulseY = this.y + 3 + i * 3;
                        const pulseIntensity = Math.sin(this.animationTimer * 3 + i) * 0.5 + 0.5;
                        ctx.fillStyle = `rgba(255, 255, 255, ${pulseIntensity * 0.8})`;
                        ctx.fillRect(this.x + this.width/2 - 0.25, pulseY, 0.5, 1);
                    }
                    
                    // 弹头高光
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(this.x + this.width/2 - 0.25, this.y, 0.5, 1);
                    
                } else if (this.type === 'boss') {
                    // Boss子弹 - 红色重型炮弹
                    // 炮弹主体
                    ctx.fillStyle = '#cc0000';
                    ctx.fillRect(this.x, this.y + 2, this.width, this.height - 4);
                    
                    // 炮弹头部
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x, this.y + this.height - 4);
                    ctx.lineTo(this.x + this.width, this.y + this.height - 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 炮弹尾部
                    ctx.fillStyle = '#990000';
                    ctx.fillRect(this.x + 1, this.y, this.width - 2, 4);
                    
                    // 金属条纹
                    ctx.fillStyle = '#ffaa00';
                    for (let i = 0; i < 2; i++) {
                        ctx.fillRect(this.x + 2, this.y + 4 + i * 4, this.width - 4, 1);
                    }
                    
                    // 威胁光芒
                    const threatGlow = Math.sin(this.animationTimer * 2) * 0.4 + 0.6;
                    ctx.fillStyle = `rgba(255, 0, 0, ${threatGlow * 0.3})`;
                    ctx.fillRect(this.x - 2, this.y, this.width + 4, this.height);
                    
                } else if (this.type === 'fast') {
                    // 快速敌机子弹 - 青色高速针弹
                    // 针弹主体（极细）
                    ctx.fillStyle = '#00aaaa';
                    ctx.fillRect(this.x + this.width/2 - 0.5, this.y + 1, 1, this.height - 2);
                    
                    // 针尖
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 0.5, this.y + this.height - 2);
                    ctx.lineTo(this.x + this.width/2 + 0.5, this.y + this.height - 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 针尾
                    ctx.fillStyle = '#006666';
                    ctx.fillRect(this.x + this.width/2 - 1, this.y, 2, 2);
                    
                    // 高速轨迹
                    const speedTrail = Math.sin(this.animationTimer * 6) * 0.4 + 0.6;
                    ctx.fillStyle = `rgba(0, 255, 255, ${speedTrail * 0.6})`;
                    ctx.fillRect(this.x + this.width/2 - 0.25, this.y, 0.5, this.height);
                    
                    // 针尖高光
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(this.x + this.width/2 - 0.25, this.y + this.height - 1, 0.5, 1);
                    
                } else if (this.type === 'heavy') {
                    // 重型敌机子弹 - 重型榴弹炮弹风格
                    // 爆炸威胁光环
                    const explosiveGlow = Math.sin(this.animationTimer * 2) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 80, 0, ${explosiveGlow * 0.4})`;
                    ctx.fillRect(this.x + this.width/2 - 4, this.y - 1, 8, this.height + 2);
                    
                    // 炮弹主体（粗壮）
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + this.width/2 - 3, this.y, 6, this.height);
                    
                    // 炮弹阴影
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(this.x + this.width/2 + 2, this.y, 1, this.height);
                    
                    // 金属环纹
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 2, 5, 1);
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 6, 5, 1);
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 10, 5, 1);
                    
                    // 爆炸装药指示
                    ctx.fillStyle = '#ff6600';
                    ctx.fillRect(this.x + this.width/2 - 1.5, this.y + 1, 3, this.height - 2);
                    
                    // 装药核心
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(this.x + this.width/2 - 0.5, this.y + 2, 1, this.height - 4);
                    
                    // 榴弹头部
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 3.5, this.y + this.height - 6);
                    ctx.lineTo(this.x + this.width/2 + 3.5, this.y + this.height - 6);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 引信头
                    ctx.fillStyle = '#cccccc';
                    ctx.fillRect(this.x + this.width/2 - 1.5, this.y + this.height - 4, 3, 2);
                    
                    // 引信尖端
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 1, this.y + this.height - 2);
                    ctx.lineTo(this.x + this.width/2 + 1, this.y + this.height - 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 炮弹尾翼
                    ctx.fillStyle = '#666666';
                    ctx.fillRect(this.x + this.width/2 - 4, this.y, 1, 3);
                    ctx.fillRect(this.x + this.width/2 + 3, this.y, 1, 3);
                    
                    // 爆炸火花
                    for (let i = 0; i < 4; i++) {
                        const sparkX = this.x + this.width/2 + (Math.random() - 0.5) * 6;
                        const sparkY = this.y + Math.random() * this.height;
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(sparkX, sparkY, 0.5, 1);
                    }
                    
                } else if (this.type === 'armored') {
                    // 装甲敌机子弹 - 重装穿甲弹风格
                    // 钢铁阴影
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 1, 6, this.height);
                    
                    // 穿甲弹主体（最粗壮）
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + this.width/2 - 3, this.y, 6, this.height);
                    
                    // 钢铁装甲纹理
                    ctx.fillStyle = '#555555';
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 2, 5, 1);
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 6, 5, 1);
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 10, 5, 1);
                    
                    // 装甲板边缘
                    ctx.fillStyle = '#777777';
                    ctx.fillRect(this.x + this.width/2 - 3, this.y, 1, this.height);
                    ctx.fillRect(this.x + this.width/2 + 2, this.y, 1, this.height);
                    
                    // 金属光泽条
                    ctx.fillStyle = '#aaaaaa';
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y, 0.5, this.height);
                    ctx.fillRect(this.x + this.width/2 + 2, this.y, 0.5, this.height);
                    
                    // 穿甲核心
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(this.x + this.width/2 - 0.5, this.y + 1, 1, this.height - 2);
                    
                    // 穿甲弹头
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(this.x + this.width/2 - 2, this.y + this.height - 5, 4, 3);
                    
                    // 硬化弹头
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 2.5, this.y + this.height - 4);
                    ctx.lineTo(this.x + this.width/2 + 2.5, this.y + this.height - 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 穿甲尖端
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 1, this.y + this.height - 2);
                    ctx.lineTo(this.x + this.width/2 + 1, this.y + this.height - 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 装甲铆钉
                    ctx.fillStyle = '#999999';
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 4, 1, 1);
                    ctx.fillRect(this.x + this.width/2 + 1.5, this.y + 4, 1, 1);
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + 8, 1, 1);
                    ctx.fillRect(this.x + this.width/2 + 1.5, this.y + 8, 1, 1);
                    
                    // 钢铁火花
                    const sparkCount = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < sparkCount; i++) {
                        const sparkX = this.x + this.width/2 + (Math.random() - 0.5) * 5;
                        const sparkY = this.y + Math.random() * this.height;
                        ctx.fillStyle = '#ffddaa';
                        ctx.fillRect(sparkX, sparkY, 0.5, 1);
                    }
                    
                } else if (this.type === 'scout') {
                    // 侦察机子弹 - 高科技激光束风格（最细最长）
                    // 外层能量场
                    const quantumPulse = Math.sin(this.animationTimer * 6) * 0.4 + 0.6;
                    ctx.fillStyle = `rgba(0, 255, 150, ${quantumPulse * 0.3})`;
                    ctx.fillRect(this.x + this.width/2 - 1, this.y, 2, this.height);
                    
                    // 激光束主体（最细）
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + this.width/2 - 0.5, this.y, 1, this.height);
                    
                    // 激光核心
                    ctx.fillStyle = '#66ff99';
                    ctx.fillRect(this.x + this.width/2 - 0.25, this.y, 0.5, this.height);
                    
                    // 激光中心线
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(this.x + this.width/2 - 0.125, this.y, 0.25, this.height);
                    
                    // 能量脉冲节点
                    for (let i = 0; i < 4; i++) {
                        const pulseY = this.y + (i + 1) * this.height / 5;
                        const pulseIntensity = Math.sin(this.animationTimer * 5 + i * 1.5) * 0.5 + 0.5;
                        ctx.fillStyle = `rgba(255, 255, 255, ${pulseIntensity})`;
                        ctx.fillRect(this.x + this.width/2 - 0.5, pulseY, 1, 0.5);
                    }
                    
                    // 激光聚焦头
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 1, this.y + this.height - 3);
                    ctx.lineTo(this.x + this.width/2 + 1, this.y + this.height - 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 激光聚焦环
                    ctx.fillStyle = '#99ffcc';
                    ctx.fillRect(this.x + this.width/2 - 0.75, this.y + this.height - 2, 1.5, 0.5);
                    
                    // 激光尖端
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 0.5, this.y + this.height - 1);
                    ctx.lineTo(this.x + this.width/2 + 0.5, this.y + this.height - 1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 量子粒子效应
                    for (let i = 0; i < 3; i++) {
                        const particleX = this.x + this.width/2 + (Math.random() - 0.5) * 1.5;
                        const particleY = this.y + Math.random() * this.height;
                        const particleAlpha = Math.random() * 0.8 + 0.2;
                        ctx.fillStyle = `rgba(136, 255, 200, ${particleAlpha})`;
                        ctx.fillRect(particleX, particleY, 0.25, 0.5);
                    }
                    
                } else {
                    // 普通敌机子弹 - 毒刺导弹风格
                    // 毒液威胁光晕
                    const toxicGlow = Math.sin(this.animationTimer * 3) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 120, 80, ${toxicGlow * 0.4})`;
                    ctx.fillRect(this.x + this.width/2 - 1.5, this.y, 3, this.height);
                    
                    // 导弹主体
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + this.width/2 - 1, this.y, 2, this.height);
                    
                    // 导弹阴影
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(this.x + this.width/2 + 0.5, this.y, 0.5, this.height);
                    
                    // 毒液装药
                    ctx.fillStyle = '#ff6633';
                    ctx.fillRect(this.x + this.width/2 - 0.5, this.y + 1, 1, this.height - 2);
                    
                    // 毒液核心
                    ctx.fillStyle = '#ffaa44';
                    ctx.fillRect(this.x + this.width/2 - 0.25, this.y + 2, 0.5, this.height - 4);
                    
                    // 毒液纹理条
                    ctx.fillStyle = '#ff8844';
                    for (let i = 0; i < 3; i++) {
                        const stripeY = this.y + 2 + i * 3;
                        ctx.fillRect(this.x + this.width/2 - 0.75, stripeY, 1.5, 0.5);
                    }
                    
                    // 导弹头部
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 1.5, this.y + this.height - 3);
                    ctx.lineTo(this.x + this.width/2 + 1.5, this.y + this.height - 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 毒刺尖端
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2 - 0.75, this.y + this.height - 1.5);
                    ctx.lineTo(this.x + this.width/2 + 0.75, this.y + this.height - 1.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 导弹尾翼
                    ctx.fillStyle = '#666666';
                    ctx.fillRect(this.x + this.width/2 - 2, this.y, 0.5, 2);
                    ctx.fillRect(this.x + this.width/2 + 1.5, this.y, 0.5, 2);
                    
                    // 毒刺倒钩
                    ctx.fillStyle = '#ff9966';
                    ctx.fillRect(this.x + this.width/2 - 2.5, this.y + this.height - 5, 1.5, 0.5);
                    ctx.fillRect(this.x + this.width/2 + 1, this.y + this.height - 5, 1.5, 0.5);
                    
                    // 毒液泄漏效果
                    if (Math.random() < 0.4) {
                        const leakX = this.x + this.width/2 + (Math.random() - 0.5) * 2;
                        const leakY = this.y + Math.random() * this.height;
                        ctx.fillStyle = '#ffcc66';
                        ctx.fillRect(leakX, leakY, 0.5, 1);
                    }
                }
                ctx.restore();
                
                // 绘制粒子效果
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = particle.color;
                    ctx.fillRect(particle.x - 1, particle.y - 1, 2, 2);
                    ctx.restore();
                });
            }
        }

        // 敌机类
        class Enemy {
            constructor(x, y, type = 'normal') {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 30;
                this.speed = 1 + Math.random() * 2;
                this.type = type;
                this.shootTimer = 0;
                this.shootInterval = 60 + Math.random() * 120;
                this.movePattern = Math.random() < 0.3 ? 'zigzag' : 'straight';
                this.moveTimer = 0;
                this.hitFlash = 0; // 被击中闪烁效果
                this.maxHealth = 1; // 最大血量
                this.lifeTimer = 0; // 生存时间计时器
                this.behaviorState = 'normal'; // 行为状态：normal, retreating, hovering, escaping
                this.targetY = canvas.height + 50; // 目标Y位置
                this.hoverTime = 0; // 悬停时间
                this.escapeTriggered = false; // 是否触发逃跑
                
                // 根据类型设置属性
                switch(type) {
                    case 'boss':
                        this.color = '#ff0000';
                        this.health = 25;
                        this.maxHealth = 25;
                        this.width = 80;
                        this.height = 60;
                        this.speed = 0.5;
                        this.shootInterval = 30;
                        this.behaviorState = 'hovering';
                        this.targetY = 100; // Boss悬停在屏幕上方
                        this.hoverTime = 600; // 悬停10秒
                        this.phase = 1; // Boss阶段：1-3
                        this.phaseChangeTimer = 0; // 阶段变化动画计时器
                        break;
                    case 'fast':
                        this.color = '#00ffff';
                        this.health = 1;
                        this.maxHealth = 1;
                        this.speed = 3 + Math.random() * 2;
                        this.width = 30;
                        this.height = 25;
                        // 快速敌机有30%概率是穿越型（不停留直接穿过）
                        if (Math.random() < 0.3) {
                            this.behaviorState = 'passing';
                            this.speed = 4 + Math.random() * 3;
                        }
                        break;
                    case 'heavy':
                        this.color = '#ff00ff';
                        this.health = 2;
                        this.maxHealth = 2;
                        this.speed = 0.5 + Math.random();
                        this.width = 50;
                        this.height = 40;
                        // 重型敌机会悬停一段时间
                        this.behaviorState = 'hovering';
                        this.targetY = 150 + Math.random() * 200;
                        this.hoverTime = 180 + Math.random() * 120; // 3-5秒悬停
                        break;
                    case 'armored':
                        this.color = '#888888';
                        this.health = 3;
                        this.maxHealth = 3;
                        this.speed = 1;
                        this.width = 45;
                        this.height = 35;
                        this.behaviorState = 'hovering';
                        this.targetY = 120 + Math.random() * 150;
                        this.hoverTime = 240; // 4秒悬停
                        break;
                    case 'scout':
                        this.color = '#00ff00';
                        this.health = 1;
                        this.maxHealth = 1;
                        this.speed = 2;
                        this.width = 25;
                        this.height = 20;
                        // 侦察机会在受到攻击后逃跑
                        this.behaviorState = 'normal';
                        this.targetY = 200 + Math.random() * 100;
                        break;
                    default:
                        this.color = '#ff6600';
                        this.health = 1;
                        this.maxHealth = 1;
                        // 普通敌机有20%概率悬停
                        if (Math.random() < 0.2) {
                            this.behaviorState = 'hovering';
                            this.targetY = 100 + Math.random() * 200;
                            this.hoverTime = 120 + Math.random() * 60; // 2-3秒悬停
                        }
                }
            }

            update() {
                this.lifeTimer++;
                
                // Boss阶段变化动画计时器
                if (this.type === 'boss' && this.phaseChangeTimer > 0) {
                    this.phaseChangeTimer--;
                }
                
                // 根据行为状态执行不同的移动逻辑
                switch(this.behaviorState) {
                    case 'normal':
                        this.updateNormalMovement();
                        break;
                    case 'hovering':
                        this.updateHoveringMovement();
                        break;
                    case 'retreating':
                        this.updateRetreatingMovement();
                        break;
                    case 'escaping':
                        this.updateEscapingMovement();
                        break;
                    case 'passing':
                        this.updatePassingMovement();
                        break;
                }
                
                // 边界检查
                if (this.x < 0) this.x = 0;
                if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;
                
                // 更新被击中闪烁效果
                if (this.hitFlash > 0) {
                    this.hitFlash--;
                }
                
                // 敌机射击（逃跑状态下不射击）
                if (this.behaviorState !== 'escaping' && this.behaviorState !== 'retreating') {
                    this.shootTimer++;
                    if (this.shootTimer >= this.shootInterval) {
                        this.shoot();
                        this.shootTimer = 0;
                        // Boss的射击间隔不随机化，保持固定
                        if (this.type !== 'boss') {
                            this.shootInterval = 60 + Math.random() * 120;
                        }
                    }
                }
            }
            
            updateNormalMovement() {
                // 移动模式
                if (this.movePattern === 'zigzag') {
                    this.moveTimer++;
                    this.x += Math.sin(this.moveTimer * 0.1) * 2;
                }
                
                this.y += this.speed;
            }
            
            updateHoveringMovement() {
                // 向目标位置移动
                if (this.y < this.targetY) {
                    this.y += this.speed;
                    
                    // 悬停时的左右摆动
                    if (this.movePattern === 'zigzag') {
                        this.moveTimer++;
                        this.x += Math.sin(this.moveTimer * 0.1) * 1.5;
                    }
                } else {
                    // 到达目标位置，开始悬停
                    this.hoverTime--;
                    
                    // 悬停时的左右摆动
                    this.moveTimer++;
                    this.x += Math.sin(this.moveTimer * 0.05) * 1;
                    
                    // 悬停时间结束，开始撤退
                    if (this.hoverTime <= 0) {
                        this.behaviorState = 'retreating';
                        this.speed = Math.abs(this.speed) * 1.5; // 撤退时速度加快
                    }
                }
            }
            
            updateRetreatingMovement() {
                // 向上撤退
                this.y -= this.speed;
                
                // 左右摆动撤退
                this.moveTimer++;
                this.x += Math.sin(this.moveTimer * 0.15) * 2;
            }
            
            updateEscapingMovement() {
                // 快速逃离
                this.y -= this.speed * 2;
                this.x += (Math.random() - 0.5) * 4; // 随机左右移动
            }
            
            updatePassingMovement() {
                // 快速穿越，不停留
                this.y += this.speed;
                
                if (this.movePattern === 'zigzag') {
                    this.moveTimer++;
                    this.x += Math.sin(this.moveTimer * 0.2) * 3;
                }
            }
            
            // 被击中时触发闪烁效果
            takeDamage() {
                this.health--;
                this.hitFlash = 10; // 闪烁10帧
                
                // Boss阶段变化逻辑
                if (this.type === 'boss') {
                    const healthPercent = this.health / this.maxHealth;
                    let newPhase = this.phase;
                    
                    if (healthPercent <= 0.33 && this.phase < 3) {
                        newPhase = 3; // 第三阶段：血量低于33%
                    } else if (healthPercent <= 0.66 && this.phase < 2) {
                        newPhase = 2; // 第二阶段：血量低于66%
                    }
                    
                    if (newPhase !== this.phase) {
                        this.phase = newPhase;
                        this.phaseChangeTimer = 60; // 阶段变化动画持续1秒
                        
                        // 根据阶段调整属性
                        switch(this.phase) {
                            case 2:
                                this.shootInterval = 20; // 射击更频繁
                                this.speed = 0.8; // 移动更快
                                break;
                            case 3:
                                this.shootInterval = 15; // 射击非常频繁
                                this.speed = 1.2; // 移动很快
                                break;
                        }
                    }
                }
                
                // 侦察机受到攻击后逃跑
                if (this.type === 'scout' && !this.escapeTriggered) {
                    this.behaviorState = 'escaping';
                    this.escapeTriggered = true;
                    this.speed = 3; // 加速逃跑
                }
                
                // 重型敌机受到攻击后可能提前撤退
                if (this.type === 'heavy' && this.health <= 1 && this.behaviorState === 'hovering') {
                    this.behaviorState = 'retreating';
                    this.speed = Math.abs(this.speed) * 2;
                }
            }

            shoot() {

                audioManager.play('enemyShoot');
                
                // 计算朝向玩家的角度，但限制只能向下射击
                const dx = (player.x + player.width / 2) - (this.x + this.width / 2);
                const dy = (player.y + player.height / 2) - (this.y + this.height / 2);
                let angleToPlayer = Math.atan2(dx, dy);
                
                // 限制射击角度，确保敌人不会向后射击
                // 只允许向下方向射击（角度范围：-π/3 到 π/3）
                const maxAngle = Math.PI / 3; // 60度
                if (angleToPlayer < -maxAngle) {
                    angleToPlayer = -maxAngle;
                } else if (angleToPlayer > maxAngle) {
                    angleToPlayer = maxAngle;
                }
                
                // 如果玩家在敌人上方，则直接向下射击
                if (dy < 0) {
                    angleToPlayer = 0;
                }
                
                if (this.type === 'boss') {
                    // 根据Boss阶段发射不同的攻击模式
                    switch(this.phase) {
                        case 1:
                            // 第一阶段：基础扇形攻击（减少到3发）
                            const baseAngles = [-0.3, 0, 0.3];
                            baseAngles.forEach(offset => {
                                enemyBullets.push(new Bullet(
                                    this.x + this.width / 2,
                                    this.y + this.height,
                                    4,
                                    '#ff0000',
                                    'boss',
                                    angleToPlayer + offset
                                ));
                            });
                            break;
                        case 2:
                            // 第二阶段：扇形攻击（减少到5发）
                            const phase2Angles = [-0.4, -0.2, 0, 0.2, 0.4];
                            phase2Angles.forEach(offset => {
                                enemyBullets.push(new Bullet(
                                    this.x + this.width / 2,
                                    this.y + this.height,
                                    5,
                                    '#ff4400',
                                    'boss',
                                    angleToPlayer + offset
                                ));
                            });
                            break;
                        case 3:
                            // 第三阶段：强化攻击（减少到5发扇形+4发螺旋）
                            const phase3Angles = [-0.5, -0.25, 0, 0.25, 0.5];
                            phase3Angles.forEach(offset => {
                                enemyBullets.push(new Bullet(
                                    this.x + this.width / 2,
                                    this.y + this.height,
                                    6,
                                    '#ff0044',
                                    'boss',
                                    angleToPlayer + offset
                                ));
                            });
                            // 螺旋攻击（减少到4发）
                            for (let i = 0; i < 4; i++) {
                                const spiralAngle = (this.lifeTimer * 0.1) + (i * Math.PI / 2);
                                enemyBullets.push(new Bullet(
                                    this.x + this.width / 2,
                                    this.y + this.height,
                                    4,
                                    '#ff6600',
                                    'boss',
                                    spiralAngle
                                ));
                            }
                            break;
                    }
                } else if (this.type === 'fast') {
                    // 快速敌机发射单发，精准朝向玩家
                    enemyBullets.push(new Bullet(
                        this.x + this.width / 2,
                        this.y + this.height,
                        4,
                        '#00ffff',
                        'fast',
                        angleToPlayer
                    ));
                } else if (this.type === 'heavy') {
                    // 重型敌机发射三发子弹，朝向玩家
                    enemyBullets.push(new Bullet(
                        this.x + this.width / 2,
                        this.y + this.height,
                        3,
                        '#ff00ff',
                        'heavy',
                        angleToPlayer
                    ));
                    enemyBullets.push(new Bullet(
                        this.x + this.width / 2,
                        this.y + this.height,
                        3,
                        '#ff00ff',
                        'heavy',
                        angleToPlayer - 0.15
                    ));
                    enemyBullets.push(new Bullet(
                        this.x + this.width / 2,
                        this.y + this.height,
                        3,
                        '#ff00ff',
                        'heavy',
                        angleToPlayer + 0.15
                    ));
                } else if (this.type === 'armored') {
                    // 装甲敌机发射重型子弹
                    enemyBullets.push(new Bullet(
                        this.x + this.width / 2,
                        this.y + this.height,
                        2,
                        '#888888',
                        'armored',
                        angleToPlayer
                    ));
                } else if (this.type === 'scout') {
                    // 侦察机发射精准单发，直接朝向玩家
                    enemyBullets.push(new Bullet(
                        this.x + this.width / 2,
                        this.y + this.height,
                        4,
                        '#00ff00',
                        'scout',
                        angleToPlayer
                    ));
                } else {
                    // 普通敌机发射朝向玩家的单发子弹
                    enemyBullets.push(new Bullet(
                        this.x + this.width / 2,
                        this.y + this.height,
                        3,
                        '#ff6600',
                        'normal',
                        angleToPlayer
                    ));
                }
            }

            draw() {
                // 被击中闪烁效果
                const isFlashing = this.hitFlash > 0 && this.hitFlash % 4 < 2;
                
                if (this.type === 'boss') {
                    // Boss - 根据阶段变化外形
                    let bodyColor, headColor, eyeColor, legColor, fangColor, patternColor;
                    
                    if (this.phase === 1) {
                        // 第一阶段 - 蜘蛛女王（红色）
                        bodyColor = isFlashing ? '#ffffff' : '#aa0000';
                        headColor = isFlashing ? '#ffffff' : '#880000';
                        eyeColor = isFlashing ? '#000000' : '#ffff00';
                        legColor = isFlashing ? '#ffffff' : '#660000';
                        fangColor = isFlashing ? '#000000' : '#ffffff';
                        patternColor = isFlashing ? '#000000' : '#ff4444';
                    } else if (this.phase === 2) {
                        // 第二阶段 - 变异蜘蛛（紫色，更大更凶猛）
                        bodyColor = isFlashing ? '#ffffff' : '#8800aa';
                        headColor = isFlashing ? '#ffffff' : '#660088';
                        eyeColor = isFlashing ? '#000000' : '#ff00ff';
                        legColor = isFlashing ? '#ffffff' : '#440066';
                        fangColor = isFlashing ? '#000000' : '#ffff00';
                        patternColor = isFlashing ? '#000000' : '#cc44ff';
                    } else {
                        // 第三阶段 - 终极形态（黑红色，最凶猛）
                        bodyColor = isFlashing ? '#ffffff' : '#000000';
                        headColor = isFlashing ? '#ffffff' : '#440000';
                        eyeColor = isFlashing ? '#000000' : '#ff0000';
                        legColor = isFlashing ? '#ffffff' : '#220000';
                        fangColor = isFlashing ? '#000000' : '#ff0000';
                        patternColor = isFlashing ? '#000000' : '#ff0000';
                    }
                    
                    // 腹部（主体）- 根据阶段调整大小
                    const sizeMultiplier = 1 + (this.phase - 1) * 0.1;
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(this.x + this.width/4, this.y + this.height/4, this.width/2 * sizeMultiplier, this.height/2 * sizeMultiplier);
                    
                    // 头胸部
                    ctx.fillStyle = headColor;
                    ctx.fillRect(this.x + this.width/3, this.y, this.width/3 * sizeMultiplier, this.height/3);
                    
                    // 多只眼睛 - 第三阶段增加更多眼睛
                    ctx.fillStyle = eyeColor;
                    const eyeCount = this.phase === 3 ? 8 : 6;
                    for (let i = 0; i < eyeCount; i++) {
                        const eyeX = this.x + this.width/3 + (i % (this.phase === 3 ? 4 : 3)) * 5;
                        const eyeY = this.y + 5 + Math.floor(i / (this.phase === 3 ? 4 : 3)) * 4;
                        ctx.fillRect(eyeX, eyeY, 2, 2);
                    }
                    
                    // 蜘蛛腿 - 根据阶段调整数量和长度
                    ctx.fillStyle = legColor;
                    const legCount = this.phase === 3 ? 6 : 4;
                    const legLength = 8 + this.phase * 2;
                    for (let i = 0; i < legCount; i++) {
                        const legY = this.y + this.height/4 + i * (this.phase === 3 ? 6 : 8);
                        // 左侧腿
                        ctx.fillRect(this.x - legLength, legY, legLength + 4, 2);
                        ctx.fillRect(this.x - legLength - 4, legY + 2, legLength, 2);
                        // 右侧腿
                        ctx.fillRect(this.x + this.width - 4, legY, legLength + 4, 2);
                        ctx.fillRect(this.x + this.width + 4, legY + 2, legLength, 2);
                    }
                    
                    // 毒牙 - 第二阶段开始增大
                    ctx.fillStyle = fangColor;
                    const fangSize = this.phase === 1 ? 8 : this.phase === 2 ? 12 : 16;
                    ctx.fillRect(this.x + this.width/2 - 3, this.y + this.height/3 - 2, 2, fangSize);
                    ctx.fillRect(this.x + this.width/2 + 1, this.y + this.height/3 - 2, 2, fangSize);
                    
                    // 腹部花纹 - 根据阶段变化
                    ctx.fillStyle = patternColor;
                    if (this.phase === 1) {
                        ctx.fillRect(this.x + this.width/3, this.y + this.height/3, this.width/3, 3);
                        ctx.fillRect(this.x + this.width/3, this.y + this.height/2, this.width/3, 3);
                    } else if (this.phase === 2) {
                        // 第二阶段 - 更复杂的花纹
                        for (let i = 0; i < 4; i++) {
                            ctx.fillRect(this.x + this.width/4, this.y + this.height/3 + i * 4, this.width/2, 2);
                        }
                    } else {
                        // 第三阶段 - 骷髅花纹
                        ctx.fillRect(this.x + this.width/3, this.y + this.height/3, this.width/3, 2);
                        ctx.fillRect(this.x + this.width/3, this.y + this.height/2, this.width/3, 2);
                        ctx.fillRect(this.x + this.width/2 - 4, this.y + this.height/3 + 4, 8, 2);
                        ctx.fillRect(this.x + this.width/2 - 6, this.y + this.height/2 + 4, 12, 2);
                    }
                    
                    // 阶段变化特效
                    if (this.phaseChangeTimer > 0) {
                        ctx.fillStyle = this.phase === 2 ? '#ff00ff' : '#ff0000';
                        ctx.globalAlpha = 0.3 + Math.sin(this.phaseChangeTimer * 0.3) * 0.3;
                        ctx.fillRect(this.x - 10, this.y - 10, this.width + 20, this.height + 20);
                        ctx.globalAlpha = 1;
                    }
                    
                    // 绘制Boss血量条
                    const barWidth = this.width;
                    const barHeight = 6;
                    const healthPercent = this.health / this.maxHealth;
                    
                    // 血量条背景
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(this.x, this.y - 15, barWidth, barHeight);
                    
                    // 血量条
                    ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.2 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(this.x, this.y - 15, barWidth * healthPercent, barHeight);
                    
                    // 血量条边框
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x, this.y - 15, barWidth, barHeight);
                } else {
                    // 根据敌机类型绘制不同外观
                    ctx.fillStyle = isFlashing ? '#ffffff' : this.color;
                    
                    switch(this.type) {
                        case 'armored':
                            // 装甲敌机 - 甲虫风格
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#444444';
                            ctx.fillRect(this.x + 3, this.y + 2, this.width - 6, this.height - 4);
                            
                            // 甲壳
                            ctx.fillStyle = isFlashing ? '#000000' : '#666666';
                            ctx.fillRect(this.x + 5, this.y + 4, this.width - 10, this.height - 8);
                            
                            // 甲壳纹理
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#888888';
                            ctx.fillRect(this.x + 8, this.y + 6, this.width - 16, 2);
                            ctx.fillRect(this.x + 8, this.y + 10, this.width - 16, 2);
                            ctx.fillRect(this.x + 8, this.y + 14, this.width - 16, 2);
                            
                            // 触角
                            ctx.fillStyle = isFlashing ? '#000000' : '#ffffff';
                            ctx.fillRect(this.x + this.width/2 - 4, this.y - 1, 2, 4);
                            ctx.fillRect(this.x + this.width/2 + 2, this.y - 1, 2, 4);
                            
                            // 腿部
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#222222';
                            for (let i = 0; i < 3; i++) {
                                ctx.fillRect(this.x, this.y + 4 + i * 4, 3, 1);
                                ctx.fillRect(this.x + this.width - 3, this.y + 4 + i * 4, 3, 1);
                            }
                            break;
                            
                        case 'scout':
                            // 侦察机 - 蜻蜓风格
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#00cc66';
                            ctx.fillRect(this.x + 6, this.y + 4, this.width - 12, this.height - 8);
                            
                            // 翅膀
                            ctx.fillStyle = isFlashing ? '#000000' : '#00ff88';
                            ctx.fillRect(this.x, this.y + 6, 5, 2);
                            ctx.fillRect(this.x + this.width - 5, this.y + 6, 5, 2);
                            ctx.fillRect(this.x + 1, this.y + 9, 5, 2);
                            ctx.fillRect(this.x + this.width - 6, this.y + 9, 5, 2);
                            
                            // 触角
                            ctx.fillStyle = isFlashing ? '#000000' : '#ffffff';
                            ctx.fillRect(this.x + this.width/2 - 1, this.y, 2, 4);
                            
                            // 复眼
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#ff0000';
                            ctx.fillRect(this.x + this.width/2 - 3, this.y + 5, 2, 2);
                            ctx.fillRect(this.x + this.width/2 + 1, this.y + 5, 2, 2);
                            
                            if (this.behaviorState === 'escaping') {
                                // 逃跑时翅膀快速振动效果
                                ctx.fillStyle = '#ffff00';
                                ctx.fillRect(this.x - 2, this.y + 5, this.width + 4, 1);
                                ctx.fillRect(this.x - 2, this.y + 10, this.width + 4, 1);
                            }
                            break;
                            
                        case 'fast':
                            // 快速敌机 - 黄蜂风格
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#ffaa00';
                            ctx.fillRect(this.x + 4, this.y, this.width - 8, this.height);
                            
                            // 黄黑条纹
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#000000';
                            for (let i = 0; i < 3; i++) {
                                ctx.fillRect(this.x + 6, this.y + 3 + i * 4, this.width - 12, 1);
                            }
                            
                            // 翅膀
                            ctx.fillStyle = isFlashing ? '#000000' : '#ffffff';
                            ctx.fillRect(this.x, this.y + 4, 4, 6);
                            ctx.fillRect(this.x + this.width - 4, this.y + 4, 4, 6);
                            
                            // 毒刺
                            ctx.fillStyle = isFlashing ? '#000000' : '#ff0000';
                            ctx.fillRect(this.x + this.width/2 - 1, this.y + this.height, 2, 3);
                            break;
                            
                        case 'heavy':
                            // 重型敌机 - 独角仙风格
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#4400aa';
                            ctx.fillRect(this.x + 2, this.y, this.width - 4, this.height);
                            
                            // 甲壳
                            ctx.fillStyle = isFlashing ? '#000000' : '#6622cc';
                            ctx.fillRect(this.x + 4, this.y + 2, this.width - 8, this.height - 4);
                            
                            // 甲壳纹理
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#8844ee';
                            ctx.fillRect(this.x + 6, this.y + 4, this.width - 12, 2);
                            ctx.fillRect(this.x + 6, this.y + 8, this.width - 12, 2);
                            
                            // 独角
                            ctx.fillStyle = isFlashing ? '#000000' : '#ffffff';
                            ctx.fillRect(this.x + this.width/2 - 1, this.y - 3, 2, 5);
                            
                            // 腿部
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#220066';
                            for (let i = 0; i < 3; i++) {
                                ctx.fillRect(this.x, this.y + 3 + i * 3, 2, 1);
                                ctx.fillRect(this.x + this.width - 2, this.y + 3 + i * 3, 2, 1);
                            }
                            break;
                            
                        default:
                            // 普通敌机 - 蚂蚁风格
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#cc4400';
                            ctx.fillRect(this.x + 6, this.y + 2, this.width - 12, this.height - 4);
                            
                            // 头部
                            ctx.fillStyle = isFlashing ? '#000000' : '#aa3300';
                            ctx.fillRect(this.x + this.width/2 - 3, this.y, 6, 6);
                            
                            // 触角
                            ctx.fillStyle = isFlashing ? '#ffffff' : '#000000';
                            ctx.fillRect(this.x + this.width/2 - 2, this.y - 1, 1, 3);
                            ctx.fillRect(this.x + this.width/2 + 1, this.y - 1, 1, 3);
                            
                            // 腿部
                            ctx.fillStyle = isFlashing ? '#000000' : '#884422';
                            for (let i = 0; i < 2; i++) {
                                ctx.fillRect(this.x + 2, this.y + 6 + i * 3, 3, 1);
                                ctx.fillRect(this.x + this.width - 5, this.y + 6 + i * 3, 3, 1);
                            }
                            
                            // 身体分节
                            ctx.fillStyle = isFlashing ? '#000000' : '#ffffff';
                            ctx.fillRect(this.x + 8, this.y + 6, this.width - 16, 1);
                            ctx.fillRect(this.x + 8, this.y + 9, this.width - 16, 1);
                            break;
                    }
                    
                    // 为多血量敌机绘制血量指示器
                    if (this.maxHealth > 1) {
                        const barWidth = this.width * 0.8;
                        const barHeight = 3;
                        const healthPercent = this.health / this.maxHealth;
                        
                        // 血量条背景
                        ctx.fillStyle = '#333333';
                        ctx.fillRect(this.x + (this.width - barWidth) / 2, this.y - 8, barWidth, barHeight);
                        
                        // 血量条
                        ctx.fillStyle = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
                        ctx.fillRect(this.x + (this.width - barWidth) / 2, this.y - 8, barWidth * healthPercent, barHeight);
                    }
                    
                    // 行为状态指示器
                    if (this.behaviorState === 'escaping') {
                        // 逃跑状态显示警告标志
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(this.x + this.width - 8, this.y - 8, 6, 6);
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(this.x + this.width - 6, this.y - 6, 2, 2);
                    }
                }
            }
        }

        // 粒子效果类
        class Particle {
            constructor(x, y, color = null, type = 'normal') {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 30;
                this.maxLife = 30;
                this.color = color || `hsl(${Math.random() * 60 + 15}, 100%, 50%)`;
                this.size = Math.random() * 3 + 1;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.3;
                this.type = type; // 'normal', 'petal', 'pollen', 'honey'
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                
                // 花瓣类型的粒子有飘落效果
                if (this.type === 'petal') {
                    this.vy += 0.1; // 重力效果
                    this.vx += Math.sin(this.life * 0.1) * 0.1; // 飘摆效果
                }
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                switch(this.type) {
                    case 'petal':
                        // 花瓣形状
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.size * 2, this.size, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // 花瓣纹理
                        ctx.strokeStyle = '#ff1493';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(0, -this.size);
                        ctx.lineTo(0, this.size);
                        ctx.stroke();
                        break;
                        
                    case 'pollen':
                        // 花粉颗粒
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.size, this.size, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // 花粉光晕
                        ctx.fillStyle = '#ffff80';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.size * 0.5, this.size * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'honey':
                        // 蜂蜜液滴
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.ellipse(0, -this.size * 0.3, this.size * 0.8, this.size * 1.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // 高光
                        ctx.fillStyle = '#ffff80';
                        ctx.beginPath();
                        ctx.ellipse(-this.size * 0.3, -this.size * 0.6, this.size * 0.3, this.size * 0.4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    default:
                        // 默认星形粒子
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2) / 5;
                            const x = Math.cos(angle) * this.size;
                            const y = Math.sin(angle) * this.size;
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
            }
        }

        // 道具类
        class PowerUp {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 25;
                this.speed = 2;
                this.type = this.getRandomType();
                this.color = this.getColor();
                this.pulseTimer = 0;
            }

            getRandomType() {
                const types = ['health', 'shield', 'rapidFire', 'bulletUpgrade'];
                return types[Math.floor(Math.random() * types.length)];
            }

            getColor() {
                switch(this.type) {
                    case 'health': return '#ff0080';
                    case 'shield': return '#0080ff';
                    case 'rapidFire': return '#ffff00';
                    case 'bulletUpgrade': return '#ff6600';
                    default: return '#ffffff';
                }
            }

            update() {
                this.y += this.speed;
                this.pulseTimer += 0.2;
            }

            draw() {
                const pulse = Math.sin(this.pulseTimer) * 0.2 + 1;
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.scale(pulse, pulse);
                
                // 根据道具类型绘制不同的小蜜蜂风格图标
                switch(this.type) {
                    case 'health':
                        // 花蜜 - 粉色花朵
                        ctx.fillStyle = '#ff69b4';
                        // 花瓣
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2) / 5;
                            const petalX = Math.cos(angle) * 8;
                            const petalY = Math.sin(angle) * 8;
                            ctx.beginPath();
                            ctx.ellipse(petalX, petalY, 4, 6, angle, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // 花心
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 3, 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        

                    case 'shield':
                        // 蜂蜡 - 六边形蜂巢
                        ctx.fillStyle = '#ffa500';
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI * 2) / 6;
                            const x = Math.cos(angle) * 10;
                            const y = Math.sin(angle) * 10;
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        // 蜂巢纹理
                        ctx.strokeStyle = '#ff8c00';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        // 内部小六边形
                        ctx.fillStyle = '#ffb347';
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI * 2) / 6;
                            const x = Math.cos(angle) * 5;
                            const y = Math.sin(angle) * 5;
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'rapidFire':
                        // 蜂蜜 - 金色液滴
                        ctx.fillStyle = '#ffb000';
                        // 液滴形状
                        ctx.beginPath();
                        ctx.ellipse(0, -3, 6, 8, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(0, 3, 4, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // 高光
                        ctx.fillStyle = '#ffff80';
                        ctx.beginPath();
                        ctx.ellipse(-2, -5, 2, 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // 滴落效果
                        ctx.fillStyle = '#ff8c00';
                        ctx.beginPath();
                        ctx.ellipse(0, 8, 1.5, 2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'bulletUpgrade':
                        // 强化蜂针 - 橙色尖锐形状
                        ctx.fillStyle = '#ff6600';
                        // 主体针形
                        ctx.beginPath();
                        ctx.moveTo(0, -10);
                        ctx.lineTo(-4, 0);
                        ctx.lineTo(-2, 8);
                        ctx.lineTo(2, 8);
                        ctx.lineTo(4, 0);
                        ctx.closePath();
                        ctx.fill();
                        // 针尖
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.moveTo(0, -10);
                        ctx.lineTo(-2, -5);
                        ctx.lineTo(2, -5);
                        ctx.closePath();
                        ctx.fill();
                        // 能量光芒
                        ctx.fillStyle = '#ffff00';
                        for (let i = 0; i < 4; i++) {
                            const angle = (i * Math.PI * 2) / 4;
                            const rayX = Math.cos(angle) * 8;
                            const rayY = Math.sin(angle) * 8;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(rayX, rayY);
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        break;
                        
                    default:
                        // 默认 - 简单圆形
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 10, 10, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
            }

            getSymbol() {
                switch(this.type) {
                    case 'health': return '+';
                    case 'shield': return 'S';
                    case 'rapidFire': return 'R';
                    case 'bulletUpgrade': return 'U';
                    default: return '?';
                }
            }
        }

        // 射击计时器
        let shootTimer = 0;
        const normalShootInterval = 10;
        const rapidShootInterval = 5;
        
        // 根据子弹等级计算射击间隔
        function getShootInterval() {
            const bulletLevel = gameState.bulletLevel || 0;
            const hasRapidFire = gameState.activePowerUps.some(p => p.type === 'rapidFire');
            
            let baseInterval = normalShootInterval;
            if (hasRapidFire) {
                baseInterval = rapidShootInterval;
            }
            
            // 子弹等级越高，射击间隔越短
            const levelReduction = Math.min(bulletLevel * 2, 6); // 最多减少6帧
            return Math.max(baseInterval - levelReduction, 2); // 最快每2帧射击一次
        }
        
        // 启动音频上下文（需要用户交互）
        function initAudio() {
            if (audioManager.audioContext && audioManager.audioContext.state === 'suspended') {
                audioManager.audioContext.resume();
            }
        }
        
        // 键盘事件处理
        document.addEventListener('keydown', (e) => {
            // 首次按键时启动音频
            initAudio();
            
            gameState.keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                if (gameState.gameOver) {
                    restartGame();
                }
            }
            
            // 音效开关
            if (e.key.toLowerCase() === 'm') {
                e.preventDefault();
                const enabled = audioManager.toggle();
                const audioStatusElement = document.getElementById('audioStatus');
                audioStatusElement.textContent = '音效: ' + (enabled ? '开启' : '关闭');
                audioStatusElement.style.color = enabled ? '#ffff00' : '#888888';
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        // 玩家射击
        function shoot() {
            const hasRapidFire = gameState.activePowerUps.some(p => p.type === 'rapidFire');
            const bulletLevel = gameState.bulletLevel || 0;
            
            // 播放射击音效
            audioManager.play('playerShoot');
            
            // 根据道具效果和升级等级决定子弹类型和属性
            let bulletType = 'player';
            let bulletColor = '#00ffff';
            let bulletSpeed = -8;
            
            if (bulletLevel > 0) {
                bulletType = 'upgraded';
                bulletSpeed = -8 - (bulletLevel * 2); // 升级子弹速度大幅提升
                switch(bulletLevel) {
                    case 1:
                        bulletColor = '#00ff80'; // 绿色
                        break;
                    case 2:
                        bulletColor = '#ff8000'; // 橙色
                        break;
                    case 3:
                        bulletColor = '#ff0080'; // 紫红色
                        break;
                }
            }
            
            if (hasRapidFire) {
                bulletType = 'powerShot';
                bulletSpeed = -10;
            }
            
            // 基础散射模式 - 一开始就发射三发子弹，真正散开
            bullets.push(new Bullet(
                player.x + player.width / 2,
                player.y,
                bulletSpeed,
                bulletColor,
                bulletType,
                0 // 中间直射
            ));
            
            // 左右散射子弹 - 从发射点就开始散开
            bullets.push(new Bullet(
                player.x + player.width / 2 - 8,
                player.y,
                bulletSpeed * 0.95,
                bulletColor,
                bulletType,
                -0.2 // 左散射
            ));
            bullets.push(new Bullet(
                player.x + player.width / 2 + 8,
                player.y,
                bulletSpeed * 0.95,
                bulletColor,
                bulletType,
                0.2 // 右散射
            ));
            
            // 根据子弹升级等级添加更多子弹
            if (bulletLevel >= 2) {
                // 等级2+：添加更多斜向子弹
                bullets.push(new Bullet(
                    player.x + player.width / 8,
                    player.y + 8,
                    bulletSpeed * 0.8,
                    bulletColor,
                    bulletType,
                    -0.25
                ));
                bullets.push(new Bullet(
                    player.x + player.width * 7/8,
                    player.y + 8,
                    bulletSpeed * 0.8,
                    bulletColor,
                    bulletType,
                    0.25
                ));
            }
            
            if (bulletLevel >= 3) {
                // 等级3：添加更多极端角度的斜向子弹
                bullets.push(new Bullet(
                    player.x,
                    player.y + 10,
                    bulletSpeed * 0.7,
                    bulletColor,
                    bulletType,
                    -0.4
                ));
                bullets.push(new Bullet(
                    player.x + player.width,
                    player.y + 10,
                    bulletSpeed * 0.7,
                    bulletColor,
                    bulletType,
                    0.4
                ));
                // 添加额外的中间角度子弹
                bullets.push(new Bullet(
                    player.x + player.width * 0.35,
                    player.y + 7,
                    bulletSpeed * 0.85,
                    bulletColor,
                    bulletType,
                    -0.1
                ));
                bullets.push(new Bullet(
                    player.x + player.width * 0.65,
                    player.y + 7,
                    bulletSpeed * 0.85,
                    bulletColor,
                    bulletType,
                    0.1
                ));
            }
            
            // 如果有快速射击，发射更强大的扇形弹幕
            if (hasRapidFire) {
                // 中间角度的强化子弹
                bullets.push(new Bullet(
                    player.x + player.width / 2 - 5,
                    player.y + 3,
                    bulletSpeed * 0.95,
                    '#ffff00',
                    'powerShot',
                    -0.15
                ));
                bullets.push(new Bullet(
                    player.x + player.width / 2 + 5,
                    player.y + 3,
                    bulletSpeed * 0.95,
                    '#ffff00',
                    'powerShot',
                    0.15
                ));
                
                // 外侧角度的强化子弹
                bullets.push(new Bullet(
                    player.x + player.width / 4,
                    player.y + 5,
                    bulletSpeed * 0.9,
                    '#ffff00',
                    'powerShot',
                    -0.3
                ));
                bullets.push(new Bullet(
                    player.x + player.width * 3/4,
                    player.y + 5,
                    bulletSpeed * 0.9,
                    '#ffff00',
                    'powerShot',
                    0.3
                ));
            }
        }

        // 生成敌机
        function spawnEnemy() {
            const x = Math.random() * (canvas.width - 40);
            let type = 'normal';
            const rand = Math.random();
            
            // 根据关卡调整敌机类型概率
            const levelFactor = Math.min(gameState.level / 10, 1); // 关卡影响因子
            
            // 移除随机生成Boss的逻辑，Boss只能通过击杀20个敌机后强制生成
            if (rand < 0.15) {
                type = 'fast';
            } else if (rand < 0.25) {
                type = 'heavy';
            } else if (rand < 0.35 + levelFactor * 0.1) {
                type = 'armored'; // 装甲敌机，高关卡更常见
            } else if (rand < 0.45) {
                type = 'scout'; // 侦察机
            }
            
            enemies.push(new Enemy(x, -50, type));
        }
        
        // 生成道具
        function spawnPowerUp(x, y) {
            if (Math.random() < 0.3) { // 30%概率掉落道具
                powerUps.push(new PowerUp(x, y));
            }
        }
        
        // 激活道具效果
        function activatePowerUp(type) {
            switch(type) {
                case 'health':
                    gameState.lives = Math.min(gameState.lives + 1, 5);
                    break;
                case 'rapidFire':
                case 'shield':
                    // 检查是否已经有相同类型的道具激活
                    const existingPowerUp = gameState.activePowerUps.find(p => p.type === type);
                    if (existingPowerUp) {
                        // 如果已存在，重置计时器
                        existingPowerUp.timer = 300;
                    } else {
                        // 如果不存在，添加新的道具效果
                        gameState.activePowerUps.push({
                            type: type,
                            timer: 300 // 5秒效果
                        });
                    }
                    break;
                case 'bulletUpgrade':
                    // 子弹升级是永久性的，每次拾取增加一级
                    gameState.bulletLevel = Math.min((gameState.bulletLevel || 0) + 1, 3);
                    break;
            }
            updatePowerUpDisplay();
        }
        
        // 更新道具状态显示
        function updatePowerUpDisplay() {
            let displayTexts = [];
            
            // 显示临时道具效果
            if (gameState.activePowerUps.length > 0) {
                gameState.activePowerUps.forEach(powerUp => {
                    const timeLeft = Math.ceil(powerUp.timer / 60);
                    let displayText = '';
                    switch(powerUp.type) {
                        case 'rapidFire': displayText = `快速射击: ${timeLeft}s`; break;
                        case 'shield': displayText = `护盾: ${timeLeft}s`; break;
                    }
                    displayTexts.push(displayText);
                });
            }
            
            // 显示子弹升级等级和速度
            if (gameState.bulletLevel && gameState.bulletLevel > 0) {
                const bulletSpeed = 8 + (gameState.bulletLevel * 2);
                displayTexts.push(`子弹等级: ${gameState.bulletLevel} (速度: ${bulletSpeed})`);
            }
            
            powerUpStatusElement.textContent = displayTexts.join(' | ');
        }

        // 碰撞检测
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // 创建爆炸效果
        function createExplosion(x, y, type = 'normal') {
            let particleCount = 15;
            let colors = ['#ff6600', '#ffaa00', '#ff0000'];
            let particleType = 'normal';
            
            switch(type) {
                case 'bullet':
                    particleCount = 8;
                    colors = ['#00ffff', '#ffffff', '#0088ff'];
                    particleType = 'normal';
                    break;
                case 'boss':
                    // Boss蜘蛛女王 - 毒液和蛛网效果
                    particleCount = 30;
                    colors = ['#8b0000', '#ff0000', '#800080', '#000000'];
                    particleType = 'honey'; // 使用蜂蜜效果模拟毒液
                    break;
                case 'powerShot':
                    particleCount = 12;
                    colors = ['#ffff00', '#ffaa00', '#ffffff'];
                    particleType = 'pollen';
                    break;
                case 'armored':
                    // 装甲甲虫 - 甲壳碎片
                    particleCount = 20;
                    colors = ['#654321', '#8b4513', '#a0522d'];
                    particleType = 'normal';
                    break;
                case 'scout':
                    // 侦察蜻蜓 - 翅膀碎片
                    particleCount = 18;
                    colors = ['#00ced1', '#40e0d0', '#48d1cc'];
                    particleType = 'petal'; // 使用花瓣效果模拟翅膀
                    break;
                case 'fast':
                    // 快速黄蜂 - 花粉爆炸
                    particleCount = 16;
                    colors = ['#ffd700', '#ffff00', '#ffa500'];
                    particleType = 'pollen';
                    break;
                case 'heavy':
                    // 重型独角仙 - 土壤和甲壳
                    particleCount = 22;
                    colors = ['#8b4513', '#a0522d', '#d2691e'];
                    particleType = 'normal';
                    break;
                case 'normal':
                    // 普通蚂蚁 - 花瓣飞散
                    particleCount = 12;
                    colors = ['#ff69b4', '#ff1493', '#ffc0cb'];
                    particleType = 'petal';
                    break;
            }
            
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(x, y, colors[Math.floor(Math.random() * colors.length)], particleType));
            }
        }

        // 更新游戏逻辑
        function update() {
            if (gameState.gameOver) return;

            // 处理无敌时间
            if (gameState.invulnerable && gameState.invulnerableTime > 0) {
                gameState.invulnerableTime--;
                if (gameState.invulnerableTime <= 0) {
                    gameState.invulnerable = false;
                }
            }

            // 玩家移动
            if (gameState.keys['a'] && player.x > 0) {
                player.x -= player.speed;
            }
            if (gameState.keys['d'] && player.x < canvas.width - player.width) {
                player.x += player.speed;
            }
            if (gameState.keys['w'] && player.y > 0) {
                player.y -= player.speed;
            }
            if (gameState.keys['s'] && player.y < canvas.height - player.height) {
                player.y += player.speed;
            }
            
            // 处理射击
            shootTimer++;
            const currentShootInterval = getShootInterval();
            
            if (gameState.keys['j'] && shootTimer >= currentShootInterval) {
                shoot();
                shootTimer = 0;
            }

            // 更新道具效果计时器
            const previousPowerUpCount = gameState.activePowerUps.length;
            gameState.activePowerUps = gameState.activePowerUps.filter(powerUp => {
                powerUp.timer--;
                return powerUp.timer > 0;
            });
            
            // 如果道具状态发生变化，更新显示
            if (gameState.activePowerUps.length !== previousPowerUpCount) {
                updatePowerUpDisplay();
            }

            // 更新子弹
            bullets = bullets.filter(bullet => {
                bullet.update();
                return bullet.y > -bullet.height;
            });

            enemyBullets = enemyBullets.filter(bullet => {
                bullet.update();
                return bullet.y < canvas.height;
            });

            // 更新敌机
            enemies = enemies.filter(enemy => {
                enemy.update();
                
                // 根据敌机行为状态决定移除条件
                switch(enemy.behaviorState) {
                    case 'retreating':
                    case 'escaping':
                        // 撤退和逃跑的敌机从屏幕顶部消失
                        return enemy.y > -enemy.height;
                    case 'passing':
                        // 穿越型敌机从屏幕底部消失
                        return enemy.y < canvas.height + 50;
                    default:
                        // 其他敌机正常从屏幕底部消失
                        return enemy.y < canvas.height + 50;
                }
            });

            // 更新道具
            powerUps = powerUps.filter(powerUp => {
                powerUp.update();
                return powerUp.y < canvas.height;
            });

            // 更新粒子
            particles = particles.filter(particle => {
                particle.update();
                return particle.life > 0;
            });

            // 子弹与敌机碰撞
            bullets.forEach((bullet, bulletIndex) => {
                enemies.forEach((enemy, enemyIndex) => {
                    if (checkCollision(bullet, enemy)) {
                        // 播放击中音效
                        audioManager.play('hit');
                        
                        // 创建子弹击中效果
                        const explosionType = bullet.type === 'powerShot' ? 'powerShot' : 'bullet';
                        createExplosion(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, explosionType);
                        
                        bullets.splice(bulletIndex, 1);
                        enemy.takeDamage(); // 使用新的takeDamage方法
                        
                        if (enemy.health <= 0) {
                            // 播放爆炸音效
                            if (enemy.type === 'boss') {
                                audioManager.play('bossExplosion');
                            } else {
                                audioManager.play('explosion');
                            }
                            
                            // 根据敌机类型创建不同的爆炸效果
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.type);
                            
                            // 计算得分
                            let points = 10;
                            switch(enemy.type) {
                                case 'boss': points = 100; break;
                                case 'heavy': points = 30; break;
                                case 'fast': points = 20; break;
                            }
                            gameState.score += points;
                            gameState.enemiesKilled++;
                            gameState.totalEnemiesKilled++;
                            
                            // 生成道具
                            spawnPowerUp(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            
                            enemies.splice(enemyIndex, 1);
                            
                            // 检查Boss生成条件
                            if (gameState.totalEnemiesKilled % gameState.bossSpawnCount === 0) {
                                // 强制生成Boss
                                const bossX = Math.random() * (canvas.width - 80);
                                enemies.push(new Enemy(bossX, -60, 'boss'));
                            }
                            
                            // 检查关卡进度
                            if (gameState.enemiesKilled >= gameState.enemiesPerLevel) {
                                gameState.level++;
                                gameState.enemiesKilled = 0;
                                gameState.enemiesPerLevel += 5;
                            }
                        }
                    }
                });
            });
            
            // 玩家与道具碰撞
            powerUps.forEach((powerUp, powerUpIndex) => {
                if (checkCollision(player, powerUp)) {
                    // 播放道具收集音效
                    audioManager.play('powerUp');
                    
                    activatePowerUp(powerUp.type);
                    powerUps.splice(powerUpIndex, 1);
                }
            });

            // 玩家子弹与敌机子弹碰撞（特殊敌机子弹可被打掉）
            bullets.forEach((playerBullet, playerBulletIndex) => {
                enemyBullets.forEach((enemyBullet, enemyBulletIndex) => {
                    if (checkCollision(playerBullet, enemyBullet)) {
                        // 只有特殊类型的敌机子弹可以被打掉
                        if (enemyBullet.type === 'boss' || enemyBullet.type === 'heavy' || enemyBullet.type === 'armored') {
                            // 播放子弹碰撞音效
                            audioManager.play('hit');
                            
                            // 创建碰撞爆炸效果
                            createExplosion(
                                (playerBullet.x + enemyBullet.x) / 2 + (playerBullet.width + enemyBullet.width) / 4,
                                (playerBullet.y + enemyBullet.y) / 2 + (playerBullet.height + enemyBullet.height) / 4,
                                'bullet'
                            );
                            
                            // 移除两颗子弹
                            bullets.splice(playerBulletIndex, 1);
                            enemyBullets.splice(enemyBulletIndex, 1);
                            
                            // 给予少量得分奖励
                            gameState.score += 5;
                        }
                    }
                });
            });

            // 敌机子弹与玩家碰撞
            enemyBullets.forEach((bullet, bulletIndex) => {
                if (checkCollision(bullet, player) && !gameState.invulnerable) {
                    enemyBullets.splice(bulletIndex, 1);
                    
                    // 护盾效果
                    const hasShield = gameState.activePowerUps.some(p => p.type === 'shield');
                    if (hasShield) {
                        // 护盾抵挡伤害
                        createExplosion(bullet.x, bullet.y);
                    } else {
                        gameState.lives--;
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2);
                        
                        if (gameState.lives <= 0) {
                            gameState.gameOver = true;
                            gameOverElement.style.display = 'block';
                            finalScoreElement.textContent = gameState.score;
                        } else {
                            // 玩家重生效果
                            respawnPlayer();
                        }
                    }
                }
            });

            // 敌机与玩家碰撞
            enemies.forEach((enemy, enemyIndex) => {
                if (checkCollision(enemy, player) && !gameState.invulnerable) {
                    enemies.splice(enemyIndex, 1);
                    
                    // 护盾效果
                    const hasShield = gameState.activePowerUps.some(p => p.type === 'shield');
                    if (hasShield) {
                        // 护盾抵挡伤害
                        createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    } else {
                        gameState.lives--;
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2);
                        
                        if (gameState.lives <= 0) {
                            gameState.gameOver = true;
                            gameOverElement.style.display = 'block';
                            finalScoreElement.textContent = gameState.score;
                        } else {
                            // 玩家重生效果
                            respawnPlayer();
                        }
                    }
                }
            });

            // 随机生成敌机（根据关卡调整生成频率）
            const spawnRate = 0.015 + (gameState.level - 1) * 0.005;
            if (Math.random() < spawnRate) {
                spawnEnemy();
            }

            // 更新UI
            scoreElement.textContent = gameState.score;
            livesElement.textContent = gameState.lives;
            levelElement.textContent = gameState.level;
            enemiesLeftElement.textContent = gameState.enemiesPerLevel - gameState.enemiesKilled;
            bossCountdownElement.textContent = gameState.bossSpawnCount - (gameState.totalEnemiesKilled % gameState.bossSpawnCount);
            updatePowerUpDisplay();
        }

        // 绘制游戏
        function draw() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制星空背景
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 100; i++) {
                const x = (i * 37) % canvas.width;
                const y = (i * 73 + Date.now() * 0.1) % canvas.height;
                ctx.fillRect(x, y, 1, 1);
            }

            // 绘制玩家 - 小蜜蜂风格战斗机
            ctx.save();
            
            // 无敌状态闪烁效果
            if (gameState.invulnerable) {
                const flashRate = Math.floor(Date.now() / 100) % 2; // 每100ms闪烁一次
                if (flashRate === 0) {
                    ctx.globalAlpha = 0.5; // 半透明效果
                }
            }
            
            // 主机身
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x + 15, player.y, 20, 35);
            
            // 机头
            ctx.fillStyle = '#00aa00';
            ctx.beginPath();
            ctx.moveTo(player.x + 25, player.y - 5);
            ctx.lineTo(player.x + 20, player.y + 5);
            ctx.lineTo(player.x + 30, player.y + 5);
            ctx.closePath();
            ctx.fill();
            
            // 主翼
            ctx.fillStyle = '#008800';
            ctx.fillRect(player.x + 5, player.y + 12, 40, 8);
            
            // 副翼
            ctx.fillStyle = '#006600';
            ctx.fillRect(player.x + 10, player.y + 25, 30, 6);
            
            // 驾驶舱
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(player.x + 22, player.y + 8, 6, 8);
            
            // 武器系统
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(player.x + 12, player.y + 18, 3, 8);
            ctx.fillRect(player.x + 35, player.y + 18, 3, 8);
            
            // 引擎尾焰
            if (gameState.keys['w'] || gameState.keys['s'] || gameState.keys['a'] || gameState.keys['d']) {
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(player.x + 18, player.y + 35, 4, 8);
                ctx.fillRect(player.x + 28, player.y + 35, 4, 8);
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(player.x + 19, player.y + 36, 2, 6);
                ctx.fillRect(player.x + 29, player.y + 36, 2, 6);
            }
            
            // 机身细节线条
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(player.x + 24, player.y + 2, 2, 30);
            
            ctx.restore();
            
            // 绘制护盾效果
            const hasShield = gameState.activePowerUps.some(p => p.type === 'shield');
            if (hasShield) {
                ctx.save();
                ctx.strokeStyle = '#0080ff';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // 绘制子弹
            bullets.forEach(bullet => bullet.draw());
            enemyBullets.forEach(bullet => bullet.draw());

            // 绘制敌机
            enemies.forEach(enemy => enemy.draw());
            
            // 绘制道具
            powerUps.forEach(powerUp => powerUp.draw());

            // 绘制粒子效果
            particles.forEach(particle => particle.draw());
        }

        // 玩家重生函数
        function respawnPlayer() {
            // 重置子弹等级
            gameState.bulletLevel = 0;
            
            // 玩家消失效果 - 设置为屏幕外
            player.y = canvas.height + 50;
            player.x = canvas.width / 2 - 25;
            
            // 创建重生粒子效果
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: player.x + player.width / 2,
                    y: canvas.height - 20,
                    vx: (Math.random() - 0.5) * 8,
                    vy: Math.random() * -5 - 2,
                    life: 60,
                    maxLife: 60,
                    color: '#00ff00',
                    size: Math.random() * 4 + 2,
                    draw() {
                        ctx.save();
                        ctx.globalAlpha = this.life / this.maxLife;
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                        ctx.restore();
                    },
                    update() {
                        this.x += this.vx;
                        this.y += this.vy;
                        this.life--;
                        return this.life > 0;
                    }
                });
            }
            
            // 设置重生动画
            let respawnTimer = 0;
            const respawnDuration = 60; // 1秒重生时间
            
            function respawnAnimation() {
                respawnTimer++;
                
                // 玩家从底部向上移动
                const progress = respawnTimer / respawnDuration;
                const targetY = canvas.height - 80;
                player.y = canvas.height + 50 - (canvas.height + 50 - targetY) * Math.min(progress, 1);
                
                // 重生完成
                if (respawnTimer >= respawnDuration) {
                    player.y = targetY;
                    // 给予短暂无敌时间
                    gameState.invulnerable = true;
                    gameState.invulnerableTime = 120; // 2秒无敌时间
                    return;
                }
                
                requestAnimationFrame(respawnAnimation);
            }
            
            respawnAnimation();
        }

        // 重新开始游戏
        function restartGame() {
            gameState.score = 0;
            gameState.lives = 3;
            gameState.gameOver = false;
            gameState.level = 1;
            gameState.enemiesKilled = 0;
            gameState.enemiesPerLevel = 10;
            gameState.activePowerUps = []; // 清空所有激活的道具
            gameState.totalEnemiesKilled = 0;
            gameState.bossSpawnCount = 20;
            gameState.invulnerable = false; // 重置无敌状态
            gameState.invulnerableTime = 0; // 重置无敌时间
            gameState.bulletLevel = 0; // 重置子弹等级
            bullets = [];
            enemyBullets = [];
            enemies = [];
            particles = [];
            powerUps = [];
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height - 80;
            gameOverElement.style.display = 'none';
            updatePowerUpDisplay();
        }

        // 游戏主循环
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // 开始游戏
        gameLoop();
    </script>
</body>
</html>